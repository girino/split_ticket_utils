#!/usr/bin/python

import re
import mysql.connector
import os
import datetime

class SplitTicketLogParser():
    """ Parses logs generated by https://github.com/matheusd/SplitTicketLogParser server and
        returns it either as a dictionary of "filename" => dict(), or as a list of dicts. Each
        dict contains the sections of the log files as keys and the contents as the log files 
        as another dictionary. If the section contains subsections, each subsection is also a dictionary.
    """
    def __init__(self, dirname):
        """ Initializes the parser with a folder name. This should point to the "sessions" folder
            where SplitTicketLogParser writes it's logs. The parser will swipe the folder and parse
            all the files in it.
        """
        self.__data = dict([(x, self.__parse_ticket(x)) for x in self.__file_iterator(dirname)])

    def as_dict(self):
        """ Returns the parsed files as a dictionary.
        """
        # returns a copy
        return dict(self.__data)

    def as_list(self):
        """ return the parsed files as a list (no filenames, only file contents).
        """
        return [self.__data[x] for x in self.__data.keys()]

    def __file_iterator(self, path):
        for root, dirnames, filenames in os.walk(path, followlinks=True):
            for fn in filenames:
                yield os.path.join(root, fn)
        raise StopIteration()

    def __parse_ticket(self, filename):
        with open(filename) as f:
            sections = self.__parse_into_sections("".join(f.readlines()))
        data = dict()
        for s in sections:
            if self.__has_subsections(sections[s]):
                ss = self.__parse_subsections(sections[s])
                data[s] = ss
            else:
                data[s] = self.__parse_section(sections[s])
        # data['Voter Selection']['Participant Amounts'] is DCR values, unparse it
        d = data['Voter Selection']['Participant Amounts']
        data['Voter Selection']['Participant Amounts'] = [" ".join(x) for x in zip(*[iter(d)]*2)]
        return data

    def __parse_into_sections(self, log):
        split = re.split(r'====== (.*) ======', log)
        if split[0] == '':
            split = split[1:]
        return dict(zip(*[iter(split)]*2))

    def __parse_section(self, section):
        #split on \n
        split = re.split(r'\n', section)
        # remove empty strings
        split = [x for x in split if x != '']
        split = dict([re.split(r' *\= *', x, 1) for x in split])
        for s in split:
            r = re.match(r'^\[(.*)\]$', split[s])
            if r:
                split[s] = r.group(1).split(' ')
        return split
    
    def __has_subsections(self, section):
        return re.search('== (.*) ==', section)
    
    def __parse_subsections(self, section):
        split = re.split('== (.*) ==', section)
        split = [x for x in split if x != '\n' and x != '\n\n']
        sections = dict(zip(*[iter(split)]*2))
        for s in sections:
            if re.search(' = ', sections[s]):
                sections[s] = self.__parse_section(sections[s])
            else:
                sections[s] = [x for x in re.split(r'\n', sections[s]) if x != '']
                if len(sections[s]) == 1:
                    sections[s] = sections[s][0]              
        return sections


if __name__ == "__main__":
    from pprint import pprint
    t = SplitTicketLogParser('./sessions')
    pprint(t.as_list(), depth=2)
